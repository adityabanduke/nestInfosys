AWSTemplateFormatVersion: '2010-09-09'
Resources:
  UsersTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: Users
      AttributeDefinitions:
        - AttributeName: email
          AttributeType: S
      KeySchema:
        - AttributeName: email
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST # ✅ Free-tier optimized
      SSESpecification:
        SSEEnabled: true
      Tags:
        - Key: Project
          Value: NestJS-DynamoDB

  # --------------------------------------------------------------------------------------

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: LambdaDynamoDBExecutionRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaDynamoDBPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Scan
                Resource: !GetAtt UsersTable.Arn
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${UsersLambdaFunction}/*"

  # ---------------------------------------------------------------------------------------------------

  UsersLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: UsersLambdaFunction
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamoDB = new AWS.DynamoDB.DocumentClient();

          exports.handler = async (event) => {
              console.log('Event:', JSON.stringify(event, null, 2));
              let response;
              
              try {
                  switch (event.requestContext.http.method) {  // ✅ Updated for HTTP API
                      case 'POST':
                          await dynamoDB.put({
                              TableName: 'Users',
                              Item: JSON.parse(event.body),
                          }).promise();
                          response = { statusCode: 201, body: JSON.stringify({ message: 'User created' }) };
                          break;
                      case 'GET':
                          if (event.queryStringParameters && event.queryStringParameters.email) {
                              const result = await dynamoDB.get({
                                  TableName: 'Users',
                                  Key: { email: event.queryStringParameters.email },
                              }).promise();
                              response = { statusCode: 200, body: JSON.stringify(result.Item) };
                          } else {
                              const result = await dynamoDB.scan({ TableName: 'Users' }).promise();
                              response = { statusCode: 200, body: JSON.stringify(result.Items) };
                          }
                          break;
                      case 'PUT':
                          await dynamoDB.update({
                              TableName: 'Users',
                              Key: { email: JSON.parse(event.body).email },
                              UpdateExpression: 'set #name = :name, password = :password',
                              ExpressionAttributeNames: { '#name': 'name' },
                              ExpressionAttributeValues: {
                                  ':name': JSON.parse(event.body).name,
                                  ':password': JSON.parse(event.body).password,
                              },
                          }).promise();
                          response = { statusCode: 200, body: JSON.stringify({ message: 'User updated' }) };
                          break;
                      case 'DELETE':
                          await dynamoDB.delete({
                              TableName: 'Users',
                              Key: { email: event.queryStringParameters.email },
                          }).promise();
                          response = { statusCode: 200, body: JSON.stringify({ message: 'User deleted' }) };
                          break;
                      default:
                          response = { statusCode: 400, body: JSON.stringify({ message: 'Unsupported method' }) };
                  }
              } catch (error) {
                  response = { statusCode: 500, body: JSON.stringify({ message: `Error: ${error.message}` }) };
              }
              
              return response;
          };

      Timeout: 10
      MemorySize: 128 # ✅ Keeps it Free-tier
      TracingConfig:
        Mode: PassThrough # ✅ Disables expensive X-Ray tracing

  # --------------------------------------------------------------------------------------

  UsersLambdaApiGateway:
    Type: AWS::ApiGatewayV2::Api # ✅ Using HTTP API (cheaper than REST API)
    Properties:
      Name: UsersLambdaHTTPAPI
      ProtocolType: HTTP
      CorsConfiguration: # ✅ Enable CORS (optional)
        AllowOrigins:
          - '*'
        AllowMethods:
          - GET
          - POST
          - PUT
          - DELETE

  ApiGatewayInvokeRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: ApiGatewayInvokeLambdaRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - apigateway.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: APIGatewayInvokeLambda
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource: !GetAtt UsersLambdaFunction.Arn

  UsersLambdaIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref UsersLambdaApiGateway
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt UsersLambdaFunction.Arn
      PayloadFormatVersion: '2.0'
      CredentialsArn: !GetAtt ApiGatewayInvokeRole.Arn  # ✅ API Gateway IAM Role

  UsersLambdaRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref UsersLambdaApiGateway
      RouteKey: ANY /users # ✅ All methods to the same Lambda
      Target: !Sub 'integrations/${UsersLambdaIntegration}'

  UsersLambdaStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref UsersLambdaApiGateway
      StageName: dev
      AutoDeploy: true # ✅ No need for explicit deployments (reduces costs)

  UsersLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref UsersLambdaFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${UsersLambdaApiGateway}/*'
